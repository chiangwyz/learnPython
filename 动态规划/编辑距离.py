"""
我们将创建一个二维数组 dp，其中 dp[i][j] 表示将 word1 的前 i 个字符转换成 word2 的前 j 个字符所需的最少操作数。

以下是解决这个问题的思路：
1. 初始化一个 (m+1) x (n+1) 的二维数组 dp，其中 m 和 n 分别是 word1 和 word2 的长度。
  dp[i][0] 表示将 word1 的前 i 个字符转换为空字符串所需的最少操作数（即删除 i 次），
  dp[0][j] 表示将空字符串转换为 word2 的前 j 个字符所需的最少操作数（即插入 j 次）。

2. 遍历 word1 和 word2，更新二维数组 dp。对于每一对字符 word1[i] 和 word2[j]：
  如果 word1[i] == word2[j]，则不需要任何操作，因此 dp[i][j] = dp[i-1][j-1]。
  如果 word1[i] != word2[j]，我们可以进行插入、删除或替换操作。选择这三种操作中的最小操作数，并加一（代表当前操作）。
  
3. 最后，dp[m][n] 就是将 word1 转换成 word2 所需的最少操作数。

疑问：
这个解法，我还是没有理解，怎么可以直接将前i个字符与前j个字符进行比较呢？比如，word1 = "aabjjj", word2="jjjgggggggg"，在这个情形下jjj不需要改变。

在编辑距离问题中，我们通常不是直接比较两个字符串的子串，而是考虑每个字符如何通过插入、删除或替换操作转换成另一个字符串。
对于您提供的例子 word1 = "aabjjj" 和 word2 = "jjjgggggggg"，虽然两个字符串都包含“jjj”，但在计算编辑距离时，我们不会直接利用这一点。

动态规划方法的关键在于它考虑了所有可能的字符操作和它们的组合。对于每一对字符 word1[i] 和 word2[j]，我们考虑以下情况：

如果当前字符相同（word1[i] == word2[j]），那么不需要额外操作，我们保持之前的操作数（即 dp[i][j] = dp[i-1][j-1]）。
如果当前字符不同，我们需要考虑三种操作：
插入一个字符到 word1（或等价地，从 word2 删除一个字符）。
从 word1 删除一个字符（或等价地，向 word2 插入一个字符）。
替换 word1 中的字符（将 word1[i] 替换成 word2[j]）。
每一步都是基于之前的最优解构建的。这意味着，即使在某个特定时刻两个子串看起来相同（如您例子中的 "jjj"），
动态规划的解法仍然是通过一步步的小操作来构建最终的转换，而不是直接识别并利用这些子串的相似性。

在您的例子中，最优解将包括删除 word1 的前两个 'a' 字符，然后插入必要的 'g' 字符以形成 word2。
在动态规划的过程中，尽管 'jjj' 在两个字符串中都出现，但这种相似性并不直接影响算法的决策过程。每一步都是基于局部的最优选择，最终达到全局的最优解。

动态规划数组 dp[i][j] 的含义以及如何通过之前的状态来更新它。
在编辑距离问题中，dp[i][j] 表示的是将 word1 的前 i 个字符转换为 word2 的前 j 个字符所需的最少操作数。
考虑到我们可以执行插入、删除和替换这三种操作，每个 dp[i][j] 的值都是基于这三种可能操作中的最优选择。

1. 删除操作 (dp[i-1][j])
  如果我们要从 word1 的前 i 个字符转换到 word2 的前 j 个字符，并且最后一个操作是删除 word1 的第 i 个字符，
  那么在这之前我们需要将 word1 的前 i-1 个字符转换为 word2 的前 j 个字符。因此，我们查看 dp[i-1][j] 的值，并加上这一步的删除操作（+1）。

2. 插入操作 (dp[i][j-1])
  如果最后一个操作是在 word1 的前 i 个字符后插入一个字符以匹配 word2 的第 j 个字符，那么在此之前，我们需要将 word1 的前 i 个字符转换为 word2 的前 j-1 个字符。
  这时我们查看 dp[i][j-1] 的值，并加上这一步的插入操作（+1）。

3. 替换操作 (dp[i-1][j-1])
  如果最后一个操作是替换 word1 的第 i 个字符以匹配 word2 的第 j 个字符，那么在此之前，我们需要将 word1 的前 i-1 个字符转换为 word2 的前 j-1 个字符。
  因此，我们查看 dp[i-1][j-1] 的值，并加上这一步的替换操作（+1）。

在每一步，我们选择这三种可能操作中的最小值作为 dp[i][j] 的值，以确保我们总是采用最少的操作数来进行转换。
这样，当我们最终达到 dp[m][n] 时（其中 m 和 n 分别是 word1 和 word2 的长度），我们得到的就是将 word1 完全转换为 word2 所需的最少操作数。
"""

class Solution:
    def minDistance(self, word1: str, word2: str) -> int:
        m, n = len(word1), len(word2)
        # 初始化dp数组
        dp = [[0] * (n + 1) for _ in range(m + 1)]

        # 初始化边界条件
        for i in range(m + 1):
            dp[i][0] = i
        for j in range(n + 1):
            dp[0][j] = j

        # 动态规划计算所有dp值
        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if word1[i - 1] == word2[j - 1]:
                    dp[i][j] = dp[i - 1][j - 1]
                else:
                    dp[i][j] = min(dp[i - 1][j],    # 删除操作
                                   dp[i][j - 1],    # 插入操作
                                   dp[i - 1][j - 1] # 替换操作
                                  ) + 1
        return dp[m][n]








