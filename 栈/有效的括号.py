"""
这个代码是一个有效的括号匹配算法，用于判断给定的字符串 s 是否是有效的括号序列。它主要使用了栈的数据结构来处理这个问题。工作原理如下：

1. 括号匹配关系定义：定义了一个字典 bracket_map 来存储括号的配对关系。例如，右括号 ")" 对应的左括号是 "("。
2 初始化栈：创建了一个空的列表 stack 来模拟栈的行为。
3 遍历字符串：对给定字符串 s 中的每个字符进行遍历。
4 处理右括号：如果当前字符是右括号（在 bracket_map 中存在），则执行以下操作：
  如果栈不为空且栈顶元素是与当前右括号匹配的左括号，则弹出栈顶元素。
   否则，说明括号序列不匹配，直接返回 False。
5 处理左括号：如果当前字符是左括号，直接将其压入栈中。
6 最终校验：遍历完所有字符后，如果栈为空，则说明所有括号都正确匹配，返回 True；否则返回 False。

总的来说，这个算法正确地实现了括号匹配的检查，适用于如 "()", "{}", "[]", "({[]})" 等多种括号组合的情况。
如果栈为空，意味着所有的括号都找到了匹配的另一半，字符串 s 是有效的括号序列。
"""


class Solution:
    def isValid(self, s: str) -> bool:
        # 定义括号的匹配关系
        bracket_map = {
            ")": "(",  # 右括号 ")" 对应的左括号 "("
            "}": "{",  # 右括号 "}" 对应的左括号 "{"
            "]": "["  # 右括号 "]" 对应的左括号 "["
        }
        # 初始化栈
        stack = []

        # 遍历字符串中的每个字符
        for char in s:
            # 如果字符是右括号
            if char in bracket_map:
                # 如果栈非空且栈顶元素是匹配的左括号
                if stack and stack[-1] == bracket_map[char]:
                    stack.pop()  # 弹出栈顶元素
                else:
                    return False  # 不匹配，返回 False
            else:
                # 如果是左括号，压入栈中
                stack.append(char)

        # 如果栈为空，说明括号完全匹配，返回 True；否则返回 False
        return not stack


s1 = "()[]{}"
s2 = "()"
s3 = "((()))[{}{{)}]"

sol = Solution()

print(sol.isValid(s1))
print(sol.isValid(s2))
print(sol.isValid(s3))
