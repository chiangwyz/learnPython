"""
给定一个大小为 n 的数组 nums ，返回其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。

拓展知识：

摩尔投票算法（Boyer-Moore Majority Vote Algorithm）是一个在线性时间内（O(N)）并且只需要常数空间（O(1)）
找出数组中出现次数超过数组长度一半的元素的高效算法。这个算法特别适用于找出"多数元素"，即在数组中出现次数超过一半的元素。

摩尔投票算法（Boyer-Moore Majority Vote Algorithm）的核心在于，如果一个元素的数量超过了数组长度的一半，那么即使它与其他所有元素“对决”，其计数器也不会降到零。
这是因为每次“对决”（即一个多数元素与一个非多数元素相抵消）后，多数元素的剩余数量仍然保持超过数组长度的一半。

算法的基本思想是维护一个候选多数元素和一个计数器。遍历数组时，更新这个候选元素和计数器，最后候选元素就是所求的多数元素。下面是算法的具体步骤：

1 初始化一个候选元素（candidate）和一个计数器（count）为 0。
2 遍历数组中的每个元素：
    如果计数器为 0，我们将候选元素设置为当前遍历的元素。
    如果遍历的元素等于候选元素，则增加计数器。
    否则减少计数器。
3 遍历结束后，候选元素就是数组中的多数元素。

值得注意的是，摩尔投票算法只能用于找出多数元素（即出现次数超过数组长度一半的元素）。
如果没有这样的元素存在，算法仍然会返回一个元素，但它可能不是多数元素。
因此，在实际应用中，可能需要额外的步骤来验证候选元素是否真的是多数元素。
"""

class Solution:
    def majorityElement(self, nums: list[int]) -> int:
        count = 0  # 初始化计数器
        candidate = None  # 初始化候选多数元素为None

        # 遍历每个元素
        for num in nums:
            # 如果计数器为0，选择当前元素作为新的候选多数元素
            if count == 0:
                candidate = num
                count = 1
            else:
                # 如果当前元素等于候选多数元素，计数器加一
                if num == candidate:
                    count += 1
                # 如果当前元素不等于候选多数元素，计数器减一
                else:
                    count -= 1

        # 返回候选多数元素
        return candidate







