"""
这个算法的核心在于遍历数组的同时，不断更新在当前位置所能到达的最远距离。
如果在某个点，这个最远距离小于当前索引，说明你无法越过这个点。如果最远距离大于或等于数组的最后一个下标，说明你能到达数组的末尾。
要注意for循环内部的三段代码的执行的先后顺序。

for循环内部：
1. 最远距离的有效性：在遍历数组时，我们需要确保每一步都是有效的，即当前位置 i 是可达的。
    如果当前位置已经超出了之前计算出的最远可达距离 max_reach，
    那么后续的操作（包括更新最远距离）都没有意义，因为我们已经不能到达当前位置了。
2. 执行效率：如果当前位置不可达，那么立即返回 False 是更高效的，因为没有必要继续执行更多的操作。
3. 逻辑顺序：先进行可达性检查，然后再更新最远可达距离，这个顺序反映了我们解决问题的逻辑：
    首先判断是否能继续前进，如果可以，再看我们能走多远。
4. 保守更新策略：我们只在确认当前位置可达的情况下更新 max_reach，这样可以避免基于不可达位置的错误更新。
"""
class Solution:
    def canJump(self, nums: list[int]) -> bool:
        max_reach = 0  # 初始化最远到达位置为0

        for i in range(len(nums)):  # 遍历数组中的每个元素
            if i > max_reach:  # 如果当前位置超过了能达到的最远位置
                return False  # 无法到达，返回False

            max_reach = max(max_reach, i + nums[i])  # 更新最远到达位置

            if max_reach >= len(nums) - 1:  # 如果能达到或超过数组的最后一个位置
                return True  # 可以到达终点，返回True

        return False  # 循环结束，仍未到达终点，返回False

